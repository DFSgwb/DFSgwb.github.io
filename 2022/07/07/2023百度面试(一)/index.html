
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>2023百度面试(一) | DFSgwb</title>
        <meta name="author" content="GWB" />
        <meta name="description" content="我的技术分享" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        
        <div id="layout">
            
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>DFSGWB</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about/">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives/">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories/">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="shouMenuItems = !shouMenuItems" v-show="shouMenuItems"></div>
        <div class="title" @click="shouMenuItems = !shouMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;DFSGWB</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="shouMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>2023百度面试(一)</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/7/7
        </span>
        
        <span class="category">
            <a href="/categories/%E9%9D%A2%E8%AF%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                面试
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E9%9D%A2%E8%AF%95/" style="color: #00bcd4">面试</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E5%90%8E%E7%AB%AF/" style="color: #00bcd4">后端</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h3 id="shiro-的组件"><a href="#shiro-的组件" class="headerlink" title="shiro 的组件"></a>shiro 的组件</h3><p>Apache Shiro 是一个强大且易于使用的 Java 安全框架，提供了身份验证、授权、加密和会话管理等安全组件。Shiro 的组件包括：</p>
<blockquote>
<ul>
<li>Subject：Subject 是 Shiro 的核心组件，代表了当前用户的安全操作。Subject 可以是一个人、一台机器或者一个后台任务。</li>
<li>SecurityManager：SecurityManager 是 Shiro 的安全管理器，负责管理所有 Subject 的安全操作。SecurityManager 是 Shiro 的核心组件，它协调着所有的安全操作。</li>
<li>Authenticator：Authenticator 是 Shiro 的身份验证器，用于验证用户的身份。Authenticator 可以使用多种身份验证方式，例如用户名和密码、数字证书、单点登录等。</li>
<li>Authorizer：Authorizer 是 Shiro 的授权器，用于授权用户的访问权限。Authorizer 可以使用多种授权方式，例如基于角色的访问控制、基于权限的访问控制等。</li>
<li>Realm：Realm 是 Shiro 的数据源，用于获取用户的身份信息和访问控制信息。Realm 可以从数据库、LDAP、文件等数据源中获取用户信息和访问控制信息。</li>
<li>SessionManager：SessionManager 是 Shiro 的会话管理器，用于管理用户的会话信息。SessionManager 可以管理用户的登录状态、超时时间、会话 ID 等信息。</li>
<li>CacheManager：CacheManager 是 Shiro 的缓存管理器，用于缓存用户的身份信息和访问控制信息。CacheManager 可以使用多种缓存方式，例如内存缓存、Ehcache 缓存、Redis 缓存等。</li>
</ul>
</blockquote>
<p>通过这些组件的协作，Shiro 可以为 Java 应用程序提供全面的安全保护。</p>
<h3 id="分布式一致算法"><a href="#分布式一致算法" class="headerlink" title="分布式一致算法"></a>分布式一致算法</h3><p>分布式一致算法是一种用于解决分布式系统中数据一致性问题的算法。在分布式系统中，由于各个节点之间的通信延迟、网络故障等原因，可能会导致数据的不一致性，即不同节点上的数据可能不一致或者不完整。分布式一致算法旨在保证分布式系统中的数据在不同节点之间保持一致。</p>
<p>常见的分布式一致算法包括：</p>
<ol>
<li><p>Paxos 算法：Paxos 算法是一种经典的分布式一致算法，它通过选举一个主节点来决定数据的更新和复制过程，保证了数据的一致性。Paxos 算法具有高可用性和容错性，但是实现较为复杂。</p>
<blockquote>
<p>1.选举一个 proposer 节点，提出一个提案，提案包含提案编号和提案内容。<br>2.proposer 节点将提案发送给所有的 acceptor 节点。<br>3.Acceptors 节点接收到提案后，如果提案编号大于当前的提案编号，则接受提案，并将自己的 Accepted proposal number 和 Accepted proposal value 更新为当前的提案编号和提案内容。 4.并将提案内容广播给所有的 learner 节点。<br>5.learner 节点接收到提案内容后，将提案内容更新到自己的状态机中。也就确定了最终的提案内容。<br>如果 Proposer 节点在一段时间内没有收到超过半数的 Acceptor 节点的回复，则重新发起提案，提案编号加 1，重新开始提案流程。</p>
</blockquote>
</li>
</ol>
<pre><code class="java">//简易实现
import java.util.HashMap;
import java.util.Map;
public class Paxos&#123;
    private int proposalNumber;
    private int acceptedValue;
    private Map&lt;Integer, Integer&gt; acceptors;
    public Paxos()&#123;
        proposalNumber = 0;
        acceptedValue = -1;
        acceptors = new HashMap&lt;&gt;();
    &#125;
    public void prepare(int proposalNumber)&#123;
        if(proposalNumber &gt; this.proposalNumber)&#123;
            this.proposalNumber = proposalNumber;
        &#125;
        int maxAcceptedValue = -1;
        int maxAcceptedProposalNumber = 0;
        for(int acceptor : acceptors.keySet())&#123;
            int acceptedProposalNumber = acceptors.get(acceptor);
            if (acceptedProposalNumber &gt; maxAcceptedProposalNumber) &#123;
                maxAcceptedProposalNumber = acceptedProposalNumber;
                maxAcceptedValue = acceptor;
            &#125;
        &#125;
        if (maxAcceptedProposalNumber &gt;= proposalNumber) &#123;
            System.out.println(&quot;Proposal rejected&quot;);
        &#125; else &#123;
            System.out.println(&quot;Proposal accepted&quot;);
            acceptors.put(proposalNumber, maxAcceptedValue);
        &#125;
    &#125;
    public void accept(int proposalNumber, int value) &#123;
        if (proposalNumber &gt;= this.proposalNumber) &#123;
            this.proposalNumber = proposalNumber;
            acceptedValue = value;
            System.out.println(&quot;Accepted value: &quot; + value);
        &#125; else &#123;
            System.out.println(&quot;Proposal rejected&quot;);
        &#125;
    &#125;

    public static void main(String[] args) &#123;
        Paxos paxos = new Paxos();
        paxos.prepare(1);
        paxos.accept(1, 10);
        paxos.prepare(2);
        paxos.accept(2, 20);
        paxos.prepare(3);
        paxos.accept(3, 30);
    &#125;
&#125;
</code></pre>
<ol start="2">
<li><p>Raft 算法：Raft 算法是一种相对简单的分布式一致算法，它将分布式系统中的节点划分为 Leader、Follower 和 Candidate 三种角色，通过选举 Leader 来实现数据一致性。Raft 算法相对于 Paxos 算法来说更易于理解和实现。</p>
</li>
<li><p>ZooKeeper 算法：ZooKeeper 是一个分布式协调服务，它提供了一套高级 API，可以用于解决分布式系统中的一致性问题。ZooKeeper 使用了 ZAB（ZooKeeper Atomic Broadcast）协议来实现数据的一致性。是一种基于 Paxos 算法的分布式一致性算法，用于解决分布式系统中的数据一致性问题。ZooKeeper 算法的核心思想是通过多轮投票来选举一个 Leader 节点，并保证多个节点之间的数据一致性。ZooKeeper 算法在分布式系统中得到了广泛的应用，例如 Hadoop、Kafka 等分布式系统都使用了 ZooKeeper 算法来实现数据一致性和选举机制。</p>
</li>
<li><p>Gossip 算法：Gossip 算法是一种基于流言的分布式一致算法，它通过节点之间的通信来实现数据的一致性。Gossip 算法具有高可用性和容错性，但是实现较为复杂。</p>
</li>
</ol>
<p>这些分布式一致算法都有各自的特点和适用场景，选择合适的算法需要根据具体的分布式系统的需求和特点来决定。</p>
<h3 id="zookeeper-那些能参与投票，leader-能投票吗"><a href="#zookeeper-那些能参与投票，leader-能投票吗" class="headerlink" title="zookeeper 那些能参与投票，leader 能投票吗"></a>zookeeper 那些能参与投票，leader 能投票吗</h3><p>在 ZooKeeper 中，只有 follower 和 observer 节点可以参与投票，而 leader 节点不能投票。当一个 ZooKeeper 集群启动时，所有节点都是 follower 节点。当选举开始时，每个 follower 节点会给自己投票，并且它们还会发送投票请求给其他节点。每个节点会在收到大多数节点的投票后选择一个 leader。一旦选举完成，节点中的一个 follower 会成为 leader，而其他节点则成为 follower 或 observer。leader 节点负责处理客户端请求，并将更新的状态复制到其他节点上。follower 节点则会接受并复制 leader 节点的状态。需要注意的是，observer 节点与 follower 节点的功能相似，但它们不参与选举过程，也不具有投票权。它们只是被动地接收和复制 leader 节点的状态。</p>
<h3 id="Netty-零拷贝实现"><a href="#Netty-零拷贝实现" class="headerlink" title="Netty 零拷贝实现"></a>Netty 零拷贝实现</h3><p>Netty 零样本是指在数据传输过程中，避免将数据从内核空间复制到用户空间，从而提高数据传输的效率，在传统的数据传输方式中，数据需要从内核空间复制到用户空间，然后再复制到网络缓存区，这样会产生大量的 CPU 开销和内存拷贝，降低数据传输的效率，而 Netty 零样本拷贝技术可以避免这种情况的发生，提高数据传输的效率。</p>
<p>实现过程：</p>
<blockquote>
<p>使用 Direct Memory Buffer(直接内存缓存区)来避免数据的内存拷贝，Direct Memory Buffer 是一种直接分配在物理内存中的缓存区，它不会占用堆内存，也不会被 JVM 垃圾回收，它可以直接在内存中进行读写操作，而不需要将数据从内核空间复制到用户空间。<br>使用 ByteBuf 类来实现 Direct Memory Buffer 的操作，ByteBuf 类时 Netty 中的一个缓冲区类，它可以直接操作 Direct Memory Buffer，从而避免了数据的内存拷贝。<br>使用 FileRegion 类来实现文件的零拷贝，FileRegion 类是 Netty 中的一个文件传输类，它可以将文件从磁盘读取到内存中，而不用将文件从磁盘复制到内存中。从而避免了数据的内存拷贝。</p>
</blockquote>
<p>通过使用 Direct Memory Buffer、ByteBuf 类和 FileRegion 类，Netty 可以实现零拷贝技术，从而提高数据传输的效率。在 Netty 中，可以通过配置 ChannelOption.ALLOCATOR 参数来选择使用 Direct Memory Buffer 还是 Heap Buffer（堆内存缓冲区），从而实现零拷贝技术。</p>
<h3 id="volatile，如何感知到变量变化的"><a href="#volatile，如何感知到变量变化的" class="headerlink" title="volatile，如何感知到变量变化的"></a>volatile，如何感知到变量变化的</h3><p>在 Java 中，使用 volatile 关键字修饰的变量可以保证多线程之间的可见性，即当一个线程修改了 volatile 变量的值时，其他线程可以立即感知到这个变化，这是因为 volatile 变量的修改会立即刷新到内存中，而其他线程读取 volatile 变量时会从主内存中读取最新的值，而不是从线程的本地缓存中读取。当一个线程读取一个 volatile 变量时，它会从主内存中读取最新的值，并将这个值复制到线程的本地缓存中，当这个线程修改了这个 volatile 变量的值时，它会将这个值写回主内存中，并通知其他线程刷新缓存，其他线程读取这个 volatile 变量时，会从主内存中读取最新的值。而不是从本地缓存中读取。因此使用 volatile 关键字修饰的变量可以保证多线程之间的可见性。从而避免线程之间的数据不一致问题，但是需要注意的是，volatile 变量智能保证可见性，却不能保证原子性，如需保护原子性，需要使用 synchronized 关键字或者 Lock 锁。</p>
<h3 id="Redis-高可用"><a href="#Redis-高可用" class="headerlink" title="Redis 高可用"></a>Redis 高可用</h3><p>Redis 高可用是指在 Redis 集群中，当其中一个节点出现故障或不可用时，其他节点可以继续提供服务，保证系统的可用性和稳定性。</p>
<p>实现 Redis 高可用的常见方式有以下几种：</p>
<ol>
<li><p>主从复制（Master-Slave Replication）：通过将一个节点设置为主节点（Master），其他节点设置为从节点（Slave），主节点负责写入数据，从节点负责读取数据和备份数据。当主节点出现故障时，从节点可以自动切换为主节点，保证系统的可用性。</p>
</li>
<li><p>哨兵模式（Sentinel）：哨兵模式是在主从复制的基础上引入了哨兵节点，哨兵节点负责监控主节点的状态，并在主节点不可用时自动将一个从节点升级为主节点。哨兵模式可以实现自动故障转移和自动恢复，提高系统的可用性。</p>
</li>
<li><p>集群模式（Cluster）：集群模式是通过将数据分片存储在多个节点上，实现数据的分布式存储和负载均衡。每个节点都可以处理部分数据的读写请求，当一个节点出现故障时，其他节点可以继续提供服务。集群模式可以实现水平扩展和高性能。</p>
</li>
</ol>
<p>需要注意的是，无论是主从复制、哨兵模式还是集群模式，都需要在配置和部署上进行一定的设置和调整，以确保系统的高可用性和稳定性。</p>
<h3 id="Http-跨域问题"><a href="#Http-跨域问题" class="headerlink" title="Http 跨域问题"></a>Http 跨域问题</h3><p>在 HTTP 协议中，跨域是指在浏览器中向不同域名或端口发送请求时，由于浏览器的同源策略限制，请求会被拒绝。同源策略是浏览器的一种安全机制，用于防止恶意网站窃取用户数据。</p>
<p>要解决跨域问题，可以通过以下几种方法：</p>
<ol>
<li><p>JSONP（JSON with Padding）：JSONP 利用了 script 标签没有跨域限制的特性，通过动态创建一个 script 标签，将需要跨域获取数据的 URL 作为其 src 属性值，服务器返回的数据会被包裹在一个函数调用中，这个函数是前端预先定义好的，服务器返回的数据会作为参数传入这个函数中，从而实现跨域获取数据。</p>
</li>
<li><p>CORS（Cross-Origin Resource Sharing）：CORS 是一种新的跨域解决方案，它通过在 HTTP 头部添加一些字段来告诉浏览器是否允许当前页面跨域请求资源。如果服务器支持 CORS，且在响应头中设置了相应的字段，浏览器就会允许跨域请求。</p>
</li>
<li><p>代理服务器：通过在同域名下创建一个代理服务器，将跨域请求发送给代理服务器，再由代理服务器向目标服务器发送请求，然后将目标服务器的响应返回给前端。这样就绕过了浏览器的同源策略限制。</p>
</li>
<li><p>WebSocket：WebSocket 是一种全双工通信协议，它可以在浏览器和服务器之间建立一个持久的连接，实现实时通信。由于 WebSocket 是在 HTTP 握手阶段进行协议升级，而不是通过 XMLHttpRequest 对象发送请求，所以它不受同源策略的限制。</p>
</li>
</ol>
<p>以上是几种常见的跨域解决方案，不同的场景可以选择适合的方法来解决跨域问题。</p>
<h3 id="TCP-长连接"><a href="#TCP-长连接" class="headerlink" title="TCP 长连接"></a>TCP 长连接</h3><p>TCP 长连接是指在 TCP 连接建立后，客户端和服务器之间保持持久的连接状态，可以持续发送和接收数据，而不需要每次通信都重新建立连接。</p>
<p>实现 TCP 长连接的方法有以下几种：</p>
<ol>
<li><p>保持连接：客户端和服务器在建立连接后，双方都保持连接状态，直到其中一方主动关闭连接。这样可以避免每次通信都重新建立连接，提高通信效率。</p>
</li>
<li><p>心跳机制：客户端和服务器定期发送心跳包来维持连接状态。心跳包是一个空的或者特定格式的数据包，用于告知对方连接仍然有效。如果一方在一定时间内没有收到心跳包，就会认为连接已经断开，然后重新建立连接。</p>
</li>
<li><p>连接池：客户端和服务器建立一个连接池，事先创建多个 TCP 连接并保存在连接池中。当需要发送数据时，从连接池中获取一个可用的连接进行通信，发送完数据后，将连接返回到连接池中，以供其他请求使用。</p>
</li>
</ol>
<p>需要注意的是，长连接也需要考虑连接的稳定性和资源的占用情况。如果连接长时间没有数据传输，可以考虑关闭连接，避免资源的浪费。</p>
<h3 id="HTTP-如何操作浏览器缓存"><a href="#HTTP-如何操作浏览器缓存" class="headerlink" title="HTTP 如何操作浏览器缓存"></a>HTTP 如何操作浏览器缓存</h3><p>HTTP 可以通过设置响应头来操作浏览器缓存。以下是一些常用的操作：</p>
<ol>
<li><p>设置 Expires 头：该头部指定了一个日期&#x2F;时间，表示响应的过期时间。如果浏览器缓存中有相同的资源，并且过期时间未到，则浏览器直接从缓存中获取资源，而不发送请求到服务器。</p>
</li>
<li><p>设置 Cache-Control 头：该头部用于控制缓存的行为。常见的指令有：</p>
<ul>
<li>no-cache：表示不使用缓存，每次请求都要发送到服务器。</li>
<li>no-store：表示不缓存任何响应内容。</li>
<li>max-age：表示资源在缓存中的最大有效时间（以秒为单位）。</li>
<li>public：表示响应可以被任何缓存（包括中间代理服务器）缓存。</li>
<li>private：表示响应只能被客户端缓存，中间代理服务器不能缓存。</li>
</ul>
</li>
<li><p>设置 Last-Modified 头和 If-Modified-Since 头：服务器可以在响应中发送 Last-Modified 头，该头部指定了资源的最后修改时间。当浏览器再次请求该资源时，可以发送 If-Modified-Since 头，该头部的值为上次响应中的 Last-Modified 值。如果资源的最后修改时间与 If-Modified-Since 头的值相同，则服务器返回一个 304 Not Modified 响应，表示资源未发生变化，浏览器可以使用缓存的版本。</p>
</li>
<li><p>设置 ETag 头和 If-None-Match 头：服务器可以在响应中发送 ETag 头，该头部是一个唯一标识符，表示资源的版本。当浏览器再次请求该资源时，可以发送 If-None-Match 头，该头部的值为上次响应中的 ETag 值。如果资源的 ETag 与 If-None-Match 头的值相同，则服务器返回一个 304 Not Modified 响应，表示资源未发生变化，浏览器可以使用缓存的版本。</p>
</li>
</ol>
<p>需要注意的是，浏览器缓存是根据资源的 URL 进行缓存的，如果 URL 不同，则浏览器会认为是不同的资源，重新请求并缓存。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列是一种在应用程序之间传递消息的通信模式。它通过将消息发送到一个中间的队列中，然后由接收者从队列中获取消息进行处理。消息队列可以实现异步通信，提供解耦和可靠性。</p>
<p>在消息队列中，发送者将消息发送到队列中，而不需要直接与接收者进行通信。接收者可以根据自己的处理能力和需求从队列中获取消息进行处理。这种方式可以实现发送者和接收者之间的解耦，使得它们可以独立地进行开发和部署。</p>
<p>消息队列还可以提供可靠性保证。当消息发送到队列中时，它们会被持久化保存，即使在发送者或接收者出现故障的情况下，消息也不会丢失。一旦接收者准备好处理消息，它可以安全地从队列中获取消息进行处理。</p>
<p>消息队列还可以实现消息的广播和订阅。发送者可以将消息发送到一个主题中，而不是特定的接收者。接收者可以订阅感兴趣的主题，从而接收到相关的消息。</p>
<p>消息队列可以在分布式系统中起到重要的作用。它可以帮助解决系统之间的通信问题，提高系统的可伸缩性和可靠性。常见的消息队列系统包括 RabbitMQ、Apache Kafka 和 ActiveMQ 等。</p>
<h3 id="JWT-签名加密算法"><a href="#JWT-签名加密算法" class="headerlink" title="JWT 签名加密算法"></a>JWT 签名加密算法</h3><p>JWT（JSON Web Token）由三部分组成：Header（头部）、Payload（负载）和 Signature（签名）。</p>
<ol>
<li><p>Header（头部）：Header 包含两个部分，分别是 token 的类型（即 JWT）和所使用的算法（例如 HMAC SHA256 或 RSA 等）。头部通常采用 JSON 格式进行编码，并使用 Base64Url 编码。示例：{“alg”: “HS256”,”typ”: “JWT”}</p>
</li>
<li><p>Payload（负载）：Payload 是 JWT 的主要内容，包含了要传递的数据。Payload 可以包含一些预定义的声明（例如 iss（签发者）、exp（过期时间）、sub（主题）等）以及自定义的声明。声明分为三类：注册声明、公共声明和私有声明。载荷通常也采用 JSON 格式进行编码，并使用 Base64Url 编码。示例：{“sub”: “1234567890”,”name”: “John Doe”,”iat”: 1516239022}</p>
</li>
<li><p>Signature（签名）：Signature 用于验证消息的完整性，防止数据被篡改。Signature 的计算需要使用 Header 和 Payload 以及一个密钥（secret）来完成。具体的算法取决于 Header 中指定的算法类型。<br>示例：HMACSHA256(base64UrlEncode(header) + “.” + base64UrlEncode(payload), secret)<br>总结：<br>JWT 的头部包含了所使用的算法，负载包含了要传递的数据，签名用于验证消息的完整性。签名的计算需要使用头部、负载和密钥来完成，具体的算法由头部指定。<br>JWT 的加密算法通常包括对称加密和非对称加密两种方式。对称加密使用相同的密钥进行加密和解密，常用的算法包括 HMAC SHA256 和 AES。非对称加密使用公钥进行加密，私钥进行解密，常用的算法包括 RSA 和 ECDSA。需要注意的是，JWT 只提供了身份验证和授权的机制，但并不提供加密功能。因此，在使用 JWT 时，需要注意保护密钥的安全性，以防止密钥泄露导致数据被篡改。</p>
</li>
</ol>
<h3 id="RSA-如何运用到-jwt-中"><a href="#RSA-如何运用到-jwt-中" class="headerlink" title="RSA 如何运用到 jwt 中"></a>RSA 如何运用到 jwt 中</h3><p>RSA 是一种非对称加密算法，它使用公钥进行加密，私钥进行解密，在 JWT 中，使用 RSA 算法进行签名和验证的过程如下：</p>
<blockquote>
<ol>
<li>生成一对公钥和私钥，公钥用于签名，私钥用于验证。</li>
<li>使用私钥对 JWT 的头部和负载进行签名，生成签名字符串。签名过程通常使用 SHA256 算法。</li>
<li>使用公钥进行验证，在验证 JWT 时，使用公钥对 Header 和 Payload 进行验证，验证签名是否正确。</li>
</ol>
</blockquote>
<p>需要注意的是，使用 RSA 算法记性签名和验证时需要保护私钥的安全性，以防止私钥泄露导致数据被篡改，同时，需要将公钥传递给需要验证 JWT 的服务端，以便进行验证。在使用 RSA 算法进行签名和验证时，需要在 JWT 的 Header 中指定算法类型为 RS256。</p>
<h3 id="synchronized-和-volatile-的区别"><a href="#synchronized-和-volatile-的区别" class="headerlink" title="synchronized 和 volatile 的区别"></a>synchronized 和 volatile 的区别</h3><p>synchronized 和 volatile 是 Java 中用于实现线程安全的两种关键字，但它们有一些区别。</p>
<ol>
<li><p>访问方式：synchronized 是通过获取对象的锁来实现同步访问，而 volatile 是通过标记变量为可见性变量来实现同步访问。</p>
</li>
<li><p>作用范围：synchronized 可以用于修饰方法、代码块和静态方法，可以实现对对象或类的同步访问；而 volatile 只能修饰变量，用于实现变量的可见性。</p>
</li>
<li><p>原子性：synchronized 可以保证代码块或方法的原子性操作，即同一时间只能有一个线程访问，其他线程需要等待；而 volatile 不能保证原子性操作。</p>
</li>
<li><p>可见性：volatile 可以保证变量的可见性，即当一个线程修改了 volatile 修饰的变量的值，其他线程能够立即看到最新的值；而 synchronized 也可以实现可见性，但是需要在进入和退出同步块时，通过刷新主内存来实现。</p>
</li>
<li><p>顺序性：volatile 可以禁止指令重排序，保证代码的执行顺序；而 synchronized 也可以保证代码的有序性，即同一时间只有一个线程执行。</p>
</li>
</ol>
<p>总的来说，synchronized 用于实现线程安全的同步访问，可以保证原子性和可见性，但是性能较差；而 volatile 用于实现变量的可见性，不能保证原子性操作，但是性能较好。</p>
<h3 id="什么是上下文切换，URL-解析过程"><a href="#什么是上下文切换，URL-解析过程" class="headerlink" title="什么是上下文切换，URL 解析过程"></a>什么是上下文切换，URL 解析过程</h3><p>上下文切换是操作系统中的一种机制，用于在多任务环境中切换不同任务之间的执行上下文。当一个任务需要被中断，让另一个任务执行时，操作系统会保存当前任务的执行状态（例如寄存器的值、程序计数器等），然后加载下一个任务的执行状态，使其能够继续执行。这个过程就是上下文切换。</p>
<p>上下文切换的目的是实现多任务并发执行，提高系统的资源利用率和响应性能。但是上下文切换也会带来一定的开销，因为切换过程需要保存和恢复任务的执行状态，以及切换时可能会导致缓存失效等问题。</p>
<p>URL 解析过程是指将一个 URL（Uniform Resource Locator，统一资源定位符）转换成可理解和处理的信息的过程。URL 是用于标识互联网上资源位置的一种标准格式。URL 解析过程包括以下步骤：</p>
<ol>
<li>协议解析：解析 URL 中的协议部分，例如 http、https 等。</li>
<li>域名解析：解析 URL 中的域名部分，将域名转换成对应的 IP 地址。</li>
<li>端口解析：解析 URL 中的端口部分，确定要连接的目标端口。</li>
<li>路径解析：解析 URL 中的路径部分，确定要请求的资源路径。</li>
<li>查询参数解析：解析 URL 中的查询参数部分，获取传递给服务器的参数信息。</li>
<li>锚点解析：解析 URL 中的锚点部分，确定页面中的定位位置。</li>
<li>URL 编码解析：解析 URL 中的编码部分，将编码的字符转换成原始字符。</li>
</ol>
<p>URL 解析过程是网络通信中的重要环节，它将用户输入的 URL 转换成计算机可理解和处理的信息，以便进行网络请求和资源获取。</p>
<h3 id="Http-有哪些方法"><a href="#Http-有哪些方法" class="headerlink" title="Http 有哪些方法"></a>Http 有哪些方法</h3><p>HTTP 有以下方法：</p>
<ol>
<li>GET：用于获取资源，请求的 URL 中包含了请求的参数，响应中返回请求的资源。</li>
<li>POST：用于提交数据，将数据发送到服务器进行处理，常用于表单提交。</li>
<li>HEAD：类似于 GET 方法，但只返回响应头部信息，不返回实体主体部分。</li>
<li>PUT：用于向服务器上传新的实体，请求的 URL 中包含了请求的资源，如果资源已存在则替换。</li>
<li>DELETE：用于删除指定的资源。</li>
<li>OPTIONS：用于获取服务器支持的 HTTP 方法。</li>
<li>TRACE：用于在请求-响应链路上追踪发送的请求。</li>
<li>CONNECT：用于建立与目标资源的隧道连接。</li>
</ol>
<p>其中，GET 方法用于获取资源，不会对服务器上的数据进行修改。</p>
<h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><p>进程和线程是操作系统中的两个重要概念，它们之间有以下区别：</p>
<ol>
<li><p>定义：进程是操作系统中的一个执行单元，表示程序在计算机上的一次执行过程；线程是进程中的一个实体，是 CPU 调度的基本单位，表示程序执行流的最小单元。</p>
</li>
<li><p>资源占用：每个进程都有独立的地址空间、文件描述符、打开的文件等资源，进程之间相互独立；而线程共享进程的地址空间和资源，包括文件、I&#x2F;O 等。</p>
</li>
<li><p>并发性：由于进程拥有独立的资源，因此不同进程之间可以并发执行，互补干扰，而线程共享进程的资源，因此不同线程之间需要进程同步和互斥，以避免竞争条件和死锁等问题。</p>
</li>
<li><p>创建和销毁：创建进程需要分配独立的地址空间和资源，销毁进程需要回收这些资源；创建线程相对较快，销毁线程也较快，因为线程共享进程的资源。</p>
</li>
<li><p>切换开销：由于进程拥有独立的地址空间和资源，进程间切换的开销较大；而线程切换的开销较小，因为线程共享进程的资源。</p>
</li>
<li><p>通信方式：进程间通信需要使用特定的机制，如管道、消息队列、共享内存等；线程间通信更加方便，可以直接读写共享变量。</p>
</li>
<li><p>并发性：多个进程之间可以并发执行，每个进程有自己的执行流；线程之间也可以并发执行，但是多个线程共享同一个进程的执行流。</p>
</li>
</ol>
<p>总的来说，进程是资源分配的基本单位，线程是执行流的基本单位。进程之间相互独立，线程之间共享资源。进程切换开销大，线程切换开销小。进程间通信需要特定机制，线程间通信更加方便。</p>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div align="center">
        <strong align="center">本文作者：</strong>GWB</a> 
        <br>
        <strong align="center">当前时间：</strong>2023-07-12 16:07:05</a>
        <br>
        <strong align="center">版权声明：本文由gwb原创,本博客所有文章除特别声明外,均采用</strong>
        <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        国际许可协议。
        <br>
        <strong>转载请注明出处！</strong>
    </div>
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 DFSgwb
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;GWB
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>
            </div>
            </transition>
            <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1895164923&auto=1&height=66"></iframe>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src='/js/main.js'></script>
        <canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
        <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
        <script src='/js/fireworks.min.js'></script>
        <!--<div id="cursor"></div>
        <link rel="stylesheet" href="../source/css/cursor.min.css" />
        <script src='/js/cursor.min.js'></script>-->
        <canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
        <script src='/js/background.min.js'></script>
        
        




        
    </body>
</html>
