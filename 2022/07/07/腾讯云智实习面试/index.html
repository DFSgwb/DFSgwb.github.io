
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>腾讯云智实习面试 | DFSgwb</title>
        <meta name="author" content="GWB" />
        <meta name="description" content="我的技术分享" />
        <meta name="keywords" content="" />
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0" />
        <link rel="icon" href="/images/avatar.jpg" />
        <script src="https://cdn.staticfile.org/vue/3.2.47/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/6.3.0/css/all.min.css" />
<link rel="stylesheet" href="/css/fonts.min.css" />
<script> const mixins = {}; </script>

<script src="https://polyfill.io/v3/polyfill.min.js?features=default"></script>


<script src="https://cdn.staticfile.org/highlight.js/11.7.0/highlight.min.js"></script>
<link
    rel="stylesheet"
    href="https://cdn.staticfile.org/highlight.js/11.7.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.js"></script>
<script src="https://cdn.staticfile.org/KaTeX/0.16.4/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.16.4/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

    <meta name="generator" content="Hexo 6.3.0"></head>
    
    <body>
        
        <div id="layout">
            
            <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
            
            </transition>
            <nav id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <div class="desktop-menu">
        <a class="title" href="/">
            <span>DFSGWB</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about/">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives/">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories/">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </div>
    <div id="mobile-menu">
        <div class="curtain" @click="shouMenuItems = !shouMenuItems" v-show="shouMenuItems"></div>
        <div class="title" @click="shouMenuItems = !shouMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;DFSGWB</span>
        </div>
        <transition name="slide">
        <div class="items" v-show="shouMenuItems">
            
            <a href="/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-house fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                </div>
            </a>
            
            <a href="/about/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-id-card fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                </div>
            </a>
            
            <a href="/archives/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-box-archive fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                </div>
            </a>
            
            <a href="/categories/">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-bookmark fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width: 20px; max-width: 50px; width: 10%">
                        <i class="fa-solid fa-tags fa-fw"></i>
                    </div>
                    <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                </div>
            </a>
            
        </div>
        </transition>
    </div>
</nav>

            <transition name="into">
            <div id="main" v-show="!loading">
                <div class="article">
    <div>
        <h1>腾讯云智实习面试</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2022/7/7
        </span>
        
        <span class="category">
            <a href="/categories/%E9%9D%A2%E8%AF%95/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                面试
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E9%9D%A2%E8%AF%95/" style="color: #ffa2c4">面试</a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E5%90%8E%E7%AB%AF/" style="color: #ff7d73">后端</a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><h3 id="网盘项目"><a href="#网盘项目" class="headerlink" title="网盘项目"></a>网盘项目</h3><p>1.项目分工</p>
<p>2.文件上传，存储过程</p>
<p>3.服务器是用什么，多大？</p>
<p>4.考虑过数据丢失问题吗？如果要加强数据可靠性，有什么方法可以优化？</p>
<p>5.有考虑过其他存储系统吗？</p>
<p>6.文件量有多少？</p>
<p>7.项目比较亮点的地方？项目安全性，使用 MD5 加密</p>
<p>8.MD5 加盐加密是如何实现的，服务端收到的密码是明文的，怎么保证传输的时候不被监听？</p>
<blockquote>
<p>加盐加密是指为每个用户生成一个随机的盐值，并在哈希之前添加到他们的密码中，然后，该盐值与散列密码一起存储在数据库中，当用户登陆时，将从数据库中检索盐值并将其添加到用户输入的密码中，并对结果字符串进行哈希处理，如果生成的散列与存储在数据库中的散列匹配，则对用户进行身份验证，否则，用户将被拒绝访问。<br>为了确保密码在传输过程中不会被截获，可以使用 SSL&#x2F;TLS 协议加密客户端和服务器之间的通信，这样，即使有人截获了密码，也无法解密它。</p>
</blockquote>
<pre><code class="Java">// 生成随机盐值
public static String getSalt(int n) &#123;
    char[] chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&amp;*()&quot;.toCharArray();
    StringBuilder sb = new StringBuilder();
    for (int i = 0; i &lt; n; i++) &#123;
        char c = chars[new Random().nextInt(chars.length)];
        sb.append(c);
    &#125;
    return sb.toString();
&#125;
// 加盐MD5加密
public static String getSaltMD5(String password, String salt) &#123;
    password = md5Hex(password + salt);
    char[] cs = new char[48];
    for (int i = 0; i &lt; 48; i += 3) &#123;
        cs[i] = password.charAt(i / 3 * 2);
        char c = salt.charAt(i / 3);
        cs[i + 1] = c;
        cs[i + 2] = password.charAt(i / 3 * 2 + 1);
    &#125;
    return new String(cs);
&#125;
</code></pre>
<h3 id="Java-部分"><a href="#Java-部分" class="headerlink" title="Java 部分"></a>Java 部分</h3><p>垃圾回收的几种方法</p>
<blockquote>
<p>标记-清除算法、复制算法、标记-整理算法、分代收集算法</p>
</blockquote>
<p>1.标记-清除算法:通过标记所有活动对象，然后清除所有没有标记的对象来回收内存。缺点是效率低，内存碎片化严重。分为两个过程：标记过程和清除过程。在标记阶段，垃圾回收器会从根对象开始遍历所有可达对象，并将其标记为活动对象。在清除阶段，垃圾回收器会清除所有未标记的对象，然后回收它们所占用的内存。</p>
<p>2.复制算法：它将内存分为两个区域，每次只使用其中一个区域，当这个区域用完了，就将还活着的对象复制到另一个区域，然后清除已经使用过的区域。这样保证了每次回收的内存都是连续的，避免了内存碎片的问题。缺点是内存利用率低，但是效率高，适用于存活对象较少的场景。</p>
<p>3.标记整理法：是改进的一种标记清理法，它在清除阶段不仅会回收未标记的对象，还会将所有活动对象移动到内存的一端，然后将令一端全部清空，这样保证了内存的连续性问题，避免了内存碎片化的问题。</p>
<p>4.分代收集法：分代收集法是一种常见的垃圾回收方法，它将内存分为不同的代，每一代都有不同的回收策略，一般来说，新创建的对象会被分配到年轻代，年轻代使用复制法进行垃圾回收，老年代使用标记清除法或标记整理法进行垃圾回收。</p>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><p>1.了解哪些排序算法，快排和堆排序的区别</p>
<blockquote>
<p>冒泡排序：冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就交换位置。时间复杂度为 O(n^2)。</p>
</blockquote>
<pre><code class="Java">// 冒泡排序
public static void bubbleSort(int arr[])&#123;
    int temp;
    for(int i=0;i&lt;arr.length-1;i++)&#123;
        for(int j=0;j&lt;arr.length-1-i;j++)&#123;
            if(arr[j]&gt;arr[j+1])&#123;
                temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<blockquote>
<p>插入排序：插入排序是一种简单的排序算法，它将待排序的数列分为已排序和未排序两部分，每次从未排序的部分取出一个元素，插入到已排序的部分中的适当位置。时间复杂度为 O(n^2)。</p>
</blockquote>
<pre><code class="Java">// 插入排序
public static void insertSort(int arr[])&#123;
    int temp;
    for(int i=1;i&lt;arr.length;i++)&#123;
        for(int j=i;j&gt;0;j--)&#123;
            if(arr[j]&lt;arr[j-1])&#123;
                temp=arr[j];
                arr[j]=arr[j-1];
                arr[j-1]=temp;
            &#125;
        &#125;
    &#125;
    return arr;
&#125;
</code></pre>
<blockquote>
<p>选择排序：选择排序是一种简单的排序算法，它重复地从未排序的部分选择最小的元素，将其放到已排序的部分的末尾。时间复杂度为 O(n^2)。</p>
</blockquote>
<pre><code class="Java">// 选择排序
public static void selectSort(int arr[])&#123;
    int temp;
    for(int i=0;i&lt;arr.length-1;i++)&#123;
        int min=i;
        for(int j=i+1;j&lt;arr.length;j++)&#123;
            if(arr[j]&lt;arr[min])&#123;
                min=j;
            &#125;
        &#125;
        temp=arr[i];
        arr[i]=arr[min];
        arr[min]=temp;
    &#125;
    return arr;
&#125;
</code></pre>
<blockquote>
<p>快速排序：快速排序是一种常用的排序算法，它使用分治的思想，将待排序的数列分成两部分，一部分比另一部分小，然后对这两部分分别进行快速排序。时间复杂度为 O(nlogn)。</p>
</blockquote>
<pre><code class="Java">// 快速排序
public static void quickSort(int arr[],int low,int high)&#123;
    int i,j,temp,t;
    if(low&gt;high)&#123;
        return;
    &#125;
    i=low;
    j=high;
    temp=arr[low];
    while(i&lt;j)&#123;
        while(temp&lt;=arr[j]&amp;&amp;i&lt;j)&#123;
            j--;
        &#125;
        while(temp&gt;=arr[i]&amp;&amp;i&lt;j)&#123;
            i++;
        &#125;
        if(i&lt;j)&#123;
            t=arr[j];
            arr[j]=arr[i];
            arr[i]=t;
        &#125;
    &#125;
    arr[low]=arr[i];
    arr[i]=temp;
    quickSort(arr,low,j-1);
    quickSort(arr,j+1,high);
&#125;
</code></pre>
<blockquote>
<p>归并排序：归并排序是一种常用的排序算法，它使用分治的思想，将待排序的数列分成若干个子序列，每个子序列都是有序的，然后再将子序列合并成一个有序的序列。时间复杂度为 O(nlogn)。</p>
</blockquote>
<pre><code class="Java">// 归并排序
public static void mergeSort(int arr[],int left,int right)&#123;
    if(left&lt;right)&#123;
        int mid=(left+right)/2;
        mergeSort(arr,left,mid);
        mergeSort(arr,mid+1,right);
        merge(arr,left,mid,right);
    &#125;
&#125;

public static void merge(int arr[],int left,int mid,int right)&#123;
    int temp[]=new int[arr.length];
    int i=left;
    int j=mid+1;
    int t=0;
    while(i&lt;=mid&amp;&amp;j&lt;=right)&#123;
        if(arr[i]&lt;=arr[j])&#123;
            temp[t++]=arr[i++];
        &#125;else&#123;
            temp[t++]=arr[j++];
        &#125;
    &#125;
    while(i&lt;=mid)&#123;
        temp[t++]=arr[i++];
    &#125;
    while(j&lt;=right)&#123;
        temp[t++]=arr[j++];
    &#125;
    t=0;
    while(left&lt;=right)&#123;
        arr[left++]=temp[t++];
    &#125;
&#125;
</code></pre>
<blockquote>
<p>堆排序：堆排序是一种常用的排序算法，它使用堆这种数据结构，将待排序的数列构建成一个堆，然后依次取出堆顶元素，将其放到已排序的部分的末尾。时间复杂度为 O(nlogn)。</p>
</blockquote>
<pre><code class="Java">// 堆排序
public static void heapSort(int arr[])&#123;
    int len=arr.length;
    for(int i=len/2-1;i&gt;=0;i--)&#123;
        adjustHeap(arr,i,len);
    &#125;
    for(int j=len-1;j&gt;0;j--)&#123;
        swap(arr,0,j);
        adjustHeap(arr,0,j);
    &#125;
&#125;

public static void adjustHeap(int arr[],int i,int len)&#123;
    int temp=arr[i];
    for(int k=2*i+1;k&lt;len;k=2*k+1)&#123;
        if(k+1&lt;len&amp;&amp;arr[k]&lt;arr[k+1])&#123;
            k++;
        &#125;
        if(arr[k]&gt;temp)&#123;
            arr[i]=arr[k];
            i=k;
        &#125;else&#123;
            break;
        &#125;
    &#125;
    arr[i]=temp;
&#125;
</code></pre>
<h3 id="为什么说快排的效率最高"><a href="#为什么说快排的效率最高" class="headerlink" title="为什么说快排的效率最高"></a>为什么说快排的效率最高</h3><blockquote>
<p>快速排序的时间复杂度为 O(nlogn)，在平均情况下，它的效率是最高的。这是因为快速排序使用了分治的思想，将待排序的数列分成两部分，一部分比另一部分小，然后对这两部分分别进行快速排序。在每一次排序中，快速排序都能够将一个元素放到它最终的位置上，这样就避免了冒泡排序和插入排序中的多次交换操作，从而提高了效率。</p>
</blockquote>
<blockquote>
<p>此外，快速排序的实现比较简单，代码量较小，而且它是一种原地排序算法，不需要额外的存储空间，这也是它被广泛使用的原因之一。</p>
</blockquote>
<blockquote>
<p>然而，快速排序的最坏时间复杂度为 O(n^2)，在最坏情况下，它的效率会变得很低。为了避免这种情况，可以使用一些优化技巧，比如随机化快速排序、三路快排等。</p>
</blockquote>
<h3 id="TCP-握手过程"><a href="#TCP-握手过程" class="headerlink" title="TCP 握手过程"></a>TCP 握手过程</h3><p>TCP 握手是建立 TCP 连接时的一种协议，它包括三个步骤：</p>
<blockquote>
<p>第一次握手：客户端向服务器发送一个 SYN 包，其中 SYN 标志位被设置为 1，表示客户端请求建立连接。客户端会随机选择一个初始序列号，并将其放在 SYN 包的序列号字段中。</p>
</blockquote>
<blockquote>
<p>第二次握手：服务器收到客户端的 SYN 包后，会向客户端发送一个 ACK 包和一个 SYN 包。其中 ACK 标志位被设置为 1，表示服务器已经收到了客户端的 SYN 包；SYN 标志位也被设置为 1，表示服务器同意建立连接。服务器会随机选择一个初始序列号，并将其放在 SYN 包的序列号字段中。</p>
</blockquote>
<blockquote>
<p>第三次握手：客户端收到服务器的 ACK 包和 SYN 包后，会向服务器发送一个 ACK 包。其中 ACK 标志位被设置为 1，表示客户端已经收到了服务器的 SYN 包。客户端会将服务器的初始序列号加 1，并将其放在 ACK 包的确认号字段中。</p>
</blockquote>
<p>完成这三个步骤后，TCP 连接就建立成功了。在连接建立后，客户端和服务器可以互相发送数据。当连接关闭时，双方会进行四次握手，以确保数据传输的完整性。</p>
<h3 id="如果服务器响应的报文丢失，客户端会怎么做？"><a href="#如果服务器响应的报文丢失，客户端会怎么做？" class="headerlink" title="如果服务器响应的报文丢失，客户端会怎么做？"></a>如果服务器响应的报文丢失，客户端会怎么做？</h3><blockquote>
<p>如果客户端发送的 SYN 包丢失，客户端会超时重传 SYN 包。如果服务器响应的 SYN 包丢失，客户端会在一定时间内等待服务器的响应，如果超时还没有收到响应，客户端会重新发送 SYN 包。</p>
</blockquote>
<blockquote>
<p>如果客户端发送的 ACK 包丢失，服务器会超时重传 SYN 包和 ACK 包。如果服务器发送的 ACK 包丢失，客户端会在一定时间内等待服务器的响应，如果超时还没有收到响应，客户端会重新发送 ACK 包。</p>
</blockquote>
<blockquote>
<p>在 TCP 连接建立过程中，如果有任何一个包丢失，都会导致连接建立失败。因此，TCP 协议中的握手过程是可靠的，可以保证连接的可靠性和完整性。</p>
</blockquote>
<h3 id="超时重传的时间是多少？"><a href="#超时重传的时间是多少？" class="headerlink" title="超时重传的时间是多少？"></a>超时重传的时间是多少？</h3><blockquote>
<p>TCP 超时重传的时间是动态调整的，根据网络状况和拥塞程度进行调整。TCP 协议中使用的超时重传算法是基于自适应超时重传算法（Adaptive Retransmission Timeout，简称 ARQ）的。</p>
</blockquote>
<blockquote>
<p>在 TCP 协议中，每次发送数据时都会启动一个定时器，如果在规定的时间内没有收到对方的确认信息，就会触发超时重传机制。TCP 协议中的超时时间是根据网络延迟和拥塞程度进行动态调整的，一般情况下，超时时间会从一个较小的初始值开始，然后逐渐增加，直到收到对方的确认信息为止。</p>
</blockquote>
<blockquote>
<p>具体来说，TCP 协议中的超时时间是根据往返时间（Round Trip Time，简称 RTT）和偏差（Deviation）来计算的。RTT 是指数据从发送方发送到接收方并返回的时间，偏差是指 RTT 的变化量。TCP 协议中的超时时间一般是根据以下公式计算的：<br>Timeout &#x3D; RTT + 4 * Deviation</p>
</blockquote>
<blockquote>
<p>其中，RTT 和 Deviation 的计算需要根据具体的算法来实现。TCP 协议中常用的算法包括 Karn 算法、Jacobson 算法和 TCP Vegas 算法等</p>
</blockquote>
<h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><blockquote>
<p>TCP 协议中的超时重传机制是指在发送数据时，如果在规定的时间内没有收到对方的确认信息，就会触发超时重传机制，重新发送数据。超时重传机制是 TCP 协议中保证数据可靠性的重要机制之一。</p>
</blockquote>
<p>具体来说，TCP 协议中的超时重传机制包括以下几个步骤：</p>
<blockquote>
<p>发送数据：发送方将数据发送给接收方，并启动一个定时器。</p>
</blockquote>
<blockquote>
<p>等待确认：发送方等待接收方的确认信息，如果在规定的时间内没有收到确认信息，就会触发超时重传机制。</p>
</blockquote>
<blockquote>
<p>重传数据：发送方重新发送数据，并重新启动定时器。</p>
</blockquote>
<blockquote>
<p>等待确认：发送方等待接收方的确认信息，如果在规定的时间内没有收到确认信息，就会再次触发超时重传机制。</p>
</blockquote>
<blockquote>
<p>放弃重传：如果重传次数达到一定的阈值，发送方会放弃重传，认为数据已经丢失。</p>
</blockquote>
<p>TCP 协议中的超时重传机制是可靠的，可以保证数据的可靠性和完整性。但是，如果超时时间设置得过短，会导致过多的重传，影响网络性能；如果超时时间设置得过长，会导致数据传输的延迟。因此，TCP 协议中的超时时间是根据网络状况和拥塞程度进行动态调整的。</p>
<h3 id="synchronized-和-ReentrantLock-的区别？"><a href="#synchronized-和-ReentrantLock-的区别？" class="headerlink" title="synchronized 和 ReentrantLock 的区别？"></a>synchronized 和 ReentrantLock 的区别？</h3><p>synchronized 和 ReentrantLock 都是 Java 中用于实现线程同步的机制，它们的作用是保证多个线程之间的互斥访问。它们的区别如下：</p>
<blockquote>
<p>锁的获取方式不同：synchronized 是 Java 中的关键字，它是隐式锁，即在代码块或方法上加上 synchronized 关键字后，系统会自动加锁和释放锁。而 ReentrantLock 是 Java 中的类，它是显式锁，需要手动调用 lock()方法获取锁和 unlock()释放锁。</p>
</blockquote>
<blockquote>
<p>锁的释放方式不同：synchronized 关键字在代码块或方法执行完毕后会自动释放锁，而 ReentrantLock 需要手动调用 unlock()方法来释放锁。</p>
</blockquote>
<blockquote>
<p>锁的可重入性不同：synchronized 是可重入锁，即同一个线程可以多次获取同一个锁,不会造成死锁，而 ReentrantLock 也是可重入锁，但需要手动调用 lock()和 unlock()实现，次数要相匹配。但是，需要注意的是，synchronized 是基于 JVM 实现的，而 ReentrantLock 是基于 AQS(AbstractQueuedSynchronizer) 实现的，AQS 是一个 FIFO 队列，因此 ReentrantLock 是可以指定获取锁的顺序的。</p>
</blockquote>
<blockquote>
<p>锁的公平性不同：synchronized 是非公平锁，即线程获取锁的顺序是不确定的，而 ReentrantLock 可以是公平锁或非公平锁，可以通过构造函数来指定。</p>
</blockquote>
<blockquote>
<p>锁的灵活性不同：ReentrantLock 提供了更多的方法来控制锁的行为，比如可以设置超时时间、中断等待锁的线程等。synchronized 关键字的锁的行为比较固定，只能等待获取锁。</p>
</blockquote>
<p>总的来说，synchronized 是 Java 中内置的一种锁机制，使用方便，但灵活性较差；而 ReentrantLock 是 Java 中提供的一种可重入锁，使用时需要手动获取和释放锁，但灵活性更高，可以更好地控制锁的行为。</p>
<h3 id="syncronized-可以加锁的地方有哪些"><a href="#syncronized-可以加锁的地方有哪些" class="headerlink" title="syncronized 可以加锁的地方有哪些?"></a>syncronized 可以加锁的地方有哪些?</h3><blockquote>
<p>synchronized 关键字可以用于修饰方法和代码块，用于修饰方法时，表示对整个方法加锁，用于修饰代码块时，表示对代码块中的内容加锁。synchronized 关键字可以用于修饰实例方法、静态方法和代码块，分别表示对实例方法、静态方法和代码块中的内容加锁。</p>
</blockquote>
<h3 id="Java-里面如果要用堆的结构，可以使用哪个类？"><a href="#Java-里面如果要用堆的结构，可以使用哪个类？" class="headerlink" title="Java 里面如果要用堆的结构，可以使用哪个类？"></a>Java 里面如果要用堆的结构，可以使用哪个类？</h3><blockquote>
<p>Java 中可以使用 PriorityQueue 类来实现堆结构，PriorityQueue 类是一个优先队列，它是基于优先堆实现的，可以用来实现堆结构。PriorityQueue 类是一个无界队列，即队列的长度可以无限制地增加，PriorityQueue 类中的元素可以默认自然排序或者通过 Comparator 接口来指定排序规则，PriorityQueue 类不允许插入 null 元素。</p>
</blockquote>

    </div>
    
    
    
    
    
    
    
</div>

                <footer id="footer">
    <div align="center">
        <strong align="center">本文作者：</strong>GWB</a> 
        <br>
        <strong align="center">当前时间：</strong>2023-07-12 17:07:52</a>
        <br>
        <strong align="center">版权声明：本文由gwb原创,本博客所有文章除特别声明外,均采用</strong>
        <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">CC BY-NC-ND 4.0</a>
        国际许可协议。
        <br>
        <strong>转载请注明出处！</strong>
    </div>
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2023 DFSgwb
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;GWB
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/argvchs/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>
            </div>
            </transition>
            <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1895164923&auto=1&height=66"></iframe>
            
            <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
            </transition>
            
        </div>
        <script src='/js/main.js'></script>
        <canvas id="fireworks" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"></canvas>
        <script src="https://cdn.staticfile.org/animejs/3.2.1/anime.min.js"></script>
        <script src='/js/fireworks.min.js'></script>
        <!--<div id="cursor"></div>
        <link rel="stylesheet" href="../source/css/cursor.min.css" />
        <script src='/js/cursor.min.js'></script>-->
        <canvas id="background" style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"></canvas>
        <script src='/js/background.min.js'></script>
        
        




        
    </body>
</html>
